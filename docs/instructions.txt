Project: Discrete Logic Evaluator
---------------------------------

Overview:
---------
This project is a C++ program that evaluates propositional logic expressions.
Given an input such as "p -> q ^ p", the program will:

1. Parse the logical expression into tokens.
2. Build an expression tree based on operator precedence.
3. Evaluate the expression under all possible truth assignments of its variables.
4. Generate a truth table.
5. Determine whether the expression is a tautology, contradiction, or contingency.


------------------------------------------------
Project Folder Structure:
------------------------------------------------

Discrete-Logic-Evaluator/
â”‚
â”œâ”€â”€ src/                 # Source code implementation files
â”‚   â”œâ”€â”€ main.cpp         # Entry point of the program
â”‚   â”œâ”€â”€ tokenizer.cpp    # Converts input string into tokens
â”‚   â”œâ”€â”€ parser.cpp       # Builds an expression tree from tokens
â”‚   â”œâ”€â”€ evaluator.cpp    # Evaluates the tree and generates truth tables
â”‚
â”œâ”€â”€ include/             # Header files for each module
â”‚   â”œâ”€â”€ tokenizer.h
â”‚   â”œâ”€â”€ parser.h
â”‚   â”œâ”€â”€ evaluator.h
â”‚
â”œâ”€â”€ docs/                # Documentation
â”‚   â”œâ”€â”€ instructions.txt # Detailed explanation of the project (this file)
â”‚
â”œâ”€â”€ README.md            # project description
â”œâ”€â”€ .gitignore           # Git ignore rules for build files, binaries, etc.

------------------------------------------------
Explanation of Source Files:
------------------------------------------------

1. main.cpp
   - This is the entry point of the program.
   - Responsibilities:
     * Take input from the user (logical expression).
     * Call the tokenizer to break input into tokens.
     * Call the parser to build an expression tree.
     * Pass the tree to the evaluator to generate results.
     * Print the truth table and final classification.

2. tokenizer.cpp
   - This module processes the raw input string.
   - Responsibilities:
     * Remove whitespace.
     * Identify tokens such as variables (p, q, r) and operators (->, ^, v, Â¬, etc.).
     * Handle parentheses correctly.
     * Return a vector/list of tokens to be used by the parser.

3. parser.cpp
   - This module takes tokens and converts the infix expression (e.g., p -> q ^ p) into
     postfix (Reverse Polish Notation, RPN).

   - Responsibilities:
     * Apply operator precedence: NOT > AND > OR > IMPLIES.
     * Handle parentheses correctly.
     * Use the Shunting Yard Algorithm (stack-based parsing).

    Example:
     * input (infix): p -> q ^ p
     * Output: (postfix): p q p ^ ->

      Output: a queue or vector of tokens in postfix order (ready for the evaluator).

4. evaluator.cpp
   - This module evaluates the postfix expression (from parser.cpp).
   - Responsibilities:
     * Identify all unique variables in the expression (p, q, etc.).
     * Generate all possible truth assignments (2^n combinations).
     * Use a stack-based evaluator to compute the result of the postfix expression.
     * Build and print a truth table.
     * Classify the result as:
       - Tautology: always true
       - Contradiction: always false
       - Contingency: sometimes true, sometimes false

------------------------------------------------
Explanation of Header Files:
------------------------------------------------
- tokenizer.h: Declares functions and classes used in tokenizer.cpp
- parser.h: Declares functions and classes used in parser.cpp
- evaluator.h: Declares functions and classes used in evaluator.cpp

Headers allow different source files to share definitions without rewriting code.

------------------------------------------------
Workflow of the Program:
------------------------------------------------
1. User inputs a logical expression (example: "p -> q ^ p").
2. Tokenizer breaks it into tokens: [p, ->, q, ^, p].
3. Parser converts tokens into an expression tree.
4. Evaluator generates a truth table and final result.
5. Program outputs the truth table and classification.

------------------------------------------------
Future Extensions:
------------------------------------------------
- Add support for more logical operators (â†”, XOR, NAND, NOR).
- Add features to solve arguments using rules of inference
- Build a GUI to visualize truth tables.
- 

------------------------------------------------
Team Collaboration Notes
------------------------------------------------

ðŸ”¹ Branch Assignments
- Each team member works on their own branch:
  * tokenizer-dev   â†’ Tokenizer module
  * parser-dev      â†’ Parser module
  * evaluator-dev   â†’ Evaluator module
  * main-dev        â†’ Main program / integration

ðŸ”¹ Workflow Rules
1. Never commit directly to `main`.
2. Always commit and push to your own branch.
3. After finishing a feature or bugfix:
   - Push your branch:   git push origin <branch-name>
   - Open a Pull Request (PR) on GitHub.
   - Team reviews the code.
   - Only then merge into `main`.

ðŸ”¹ Syncing with Main
- Before starting new work, always update your branch:
  git checkout main
  git pull origin main
  git checkout <your-branch>
  git merge main

ðŸ”¹ Goal
Keep `main` branch stable and working at all times.
All new features or fixes should flow through branches â†’ PR â†’ review â†’ merge.

------------------------------------------------
End of Document
------------------------------------------------
